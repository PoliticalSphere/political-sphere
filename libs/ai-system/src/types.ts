/**
 * Shared types for ai-system. These types are designed to be Copilot-friendly
 * with clear names, JSDoc, and small, composable interfaces.
 */

export type Role = 'system' | 'user' | 'assistant' | 'tool';

/**
 * A single chat message exchanged between agents or users.
 */
export interface Message {
  id?: string;
  role: Role;
  content: string;
  name?: string;
  timestamp?: string | number | Date;
  metadata?: Record<string, unknown>;
}

/**
 * A tool call generated by an agent model.
 */
export interface ToolCall {
  id: string;
  name: string;
  arguments: unknown;
}

/**
 * Represents an LLM/tool agent participating in orchestration.
 */
export interface Agent {
  /** Unique identifier for this agent. */
  id: string;
  /** Human-readable label. */
  name?: string;
  /**
   * Optional description used by routing strategies or governance policies.
   */
  description?: string;
  /**
   * Send a sequence of messages and return the next assistant message.
   */
  respond(messages: Message[], ctx: OrchestrationContext): Promise<AgentResult>;
}

/**
 * Result produced by an Agent after responding.
 */
export interface AgentResult {
  message: Message;
  toolCalls?: ToolCall[];
  metadata?: Record<string, unknown>;
}

/**
 * Context object used during orchestration, governance, and observability.
 */
export interface OrchestrationContext {
  /** Correlation ID across a run; set by orchestrator or caller. */
  runId: string;
  /** A bag for passing arbitrary values across middleware/components. */
  bag?: Record<string, unknown>;
  /** Observability hooks for tracing and metrics. */
  observability?: Observability;
  /** Governance policies enforced by orchestrators. */
  governance?: Governance;
  /** Validators applied to inputs/outputs. */
  validators?: Validators;
  /** Pattern-specific configuration. */
  config?: Record<string, unknown>;
}

/**
 * A normalized orchestration result.
 */
export interface OrchestrationResult {
  /** Final transcript including all messages generated during orchestration. */
  transcript: Message[];
  /** The final message considered the outcome of the run. */
  output?: Message;
  /** True when orchestration ended cleanly according to the pattern. */
  completed: boolean;
  /** Any extra information the pattern exposes. */
  metadata?: Record<string, unknown>;
}

/**
 * Observability hooks for tracing and metrics. See observability/index.ts for implementations.
 */
export interface Observability {
  onStart?(event: {
    runId: string;
    pattern: string;
    agents: string[];
    input: Message[];
    config?: Record<string, unknown>;
  }): void | Promise<void>;
  onMessage?(event: {
    runId: string;
    from: string;
    message: Message;
    stage?: string;
  }): void | Promise<void>;
  onError?(event: { runId: string; error: unknown; stage?: string }): void | Promise<void>;
  onEnd?(event: { runId: string; result: OrchestrationResult }): void | Promise<void>;
}

/** Governance Types */
export interface PolicyContext {
  runId: string;
  messages: Message[];
  stage: 'pre-input' | 'pre-agent' | 'post-agent' | 'pre-output' | 'post-output' | string;
  bag?: Record<string, unknown>;
}

export interface PolicyResult {
  ok: boolean;
  violations?: PolicyViolation[];
  metadata?: Record<string, unknown>;
}

export interface PolicyViolation {
  code: string;
  message: string;
  details?: Record<string, unknown>;
}

export type Policy = (ctx: PolicyContext) => Promise<PolicyResult> | PolicyResult;

export interface Governance {
  policies: Policy[];
}

/** Validation Types */
export interface ValidatorContext {
  runId: string;
  phase: 'input' | 'output';
}

export interface ValidatorResult {
  ok: boolean;
  errors?: { path?: string; message: string }[];
  metadata?: Record<string, unknown>;
}

export type Validator = (
  value: unknown,
  ctx: ValidatorContext
) => Promise<ValidatorResult> | ValidatorResult;

export interface Validators {
  input?: Validator[];
  output?: Validator[];
}

/** Factory helper input for orchestrators */
export interface OrchestratorInit {
  pattern: 'concurrent' | 'handoff' | 'group-chat';
  agents: Agent[];
  config?: Record<string, unknown>;
  governance?: Governance;
  validators?: Validators;
  observability?: Observability;
  memory?: import('./memory').Memory; // optional transcript memory
}

export type Orchestrator = {
  run(messages: Message[], ctx?: Partial<OrchestrationContext>): Promise<OrchestrationResult>;
};

/** Utility */
export function defineAgent(agent: Agent): Agent {
  return agent;
}
